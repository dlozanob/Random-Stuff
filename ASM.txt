Usa abreviaturas en inglés para dar instrucciones

Un programa se organiza en 4 secciones:
- Inclusión de librerías y definición de símbolos
- Directivas de configuración: Ajustan parámetros generales del funcionamiento del microcontrolador
- Definición de variables: No hay tipos de variables. Cada una tiene el tamaño de bits del micro.
- Instrucciones del ensamblador

El set de instrucciones RISC dota al microcontrolador de 75 instrucciones estándar y 8 del set extendido.

Tipos de instrucciones:
- Según su operación:
  - Operaciones orientadas a byte: Operaciones aritméticas, lógicas, o de movimiento a un registro o variable.
  - Operaciones orientadas a bit: Operan un solo bit de registro o variable.
  - Operación de control: Consultan o manipulan los registros de la CPU (a excepción del registro W).
  - Operación de constantes: Utilizan una constante para su ejecución.
  - Operaciones de manejo de tablas: Permiten la lectura o escritura de memorias FLASH.
  - Operación de set extendido: Añadidas para realizar funciones especiales.
  
- Según el modo de direccionamiento:
  - Inherente: No requieren operandos para su ejecución.
  - Inmediato: Operan con constantes en operaciones aritmético-lógicas.
  - Directo: Operan con un registro o variable que es especificado como operando.
  - Relativo: Saltan a un bloque del programa dependiendo del estado de una variable. (Saltan a posiciones de memoria cercanas)
    (Máximo salto: 128 posiciones hacia arriba, 127 posiciones hacia abajo)
  - Extendido: Saltan a cualquier posición de memoria. Funciona como el relativo.
  - Indirecto: Usan apuntadores para manipular registros y variables.
  
- Según el espacio que ocupan en memoria:
  MOVFF, CALL, GOTO, MOVSF, MOVSS ocupan 4 bytes. El resto de instrucciones ocupan 2 bytes.

- Según el tiempo que tardan en ejecutarse:
  - 1 Ciclo de bus
  - 2 Ciclos de bus
  - 3 Ciclos de bus


El perro guardián es un tipo de protección ante códigos no deseados por el momento.

En la librería del micro C:\Program Files (x86)\Microchip\MPLABX\v3.30\mpasmx\p18f4550.inc se encuentran las direcciones de los registros
Pra solucionar error de ensamblador relocalizador: Propiedades del proyecto -> mpasm (Global options) -> Build in absolute mode
----------------------------------------------------------------------------------------------------------------------------------------------------------

// Para incluir librerías se usa
include <nombre de la librería>.inc

// Incluimos la librería del microcontrolador
include P18F4550.inc


// Las directivas de configuración adquieren la forma
config <parámetro a configurar>=<Estado>

// Configurar la frecuencia del oscilador
config FOSC=INTOSC_EC

// Configurar perro guardián
config WDT=OFF

// Configurar Master Clear (Reset externo)
config MCLRE=OFF


// Definición de variables. La posición de memoria (dentro de la memoria RAM) está en el rango 000h - FFFh (h denota hexadecimal)
// El Access Bank es un banco de acceso rápido, el cual se compone de las primeras 96 posiciones
// Para PIC18, todas las variables tienen 8 bits
<nombre de la variable> equ <posición de memoria>

// Ejemplos de definición de variables
aux1 equ 1h
Var1 equ 9h
Var2 equ 1h
Var3 equ 0x7FF ;0x cuando usamos letras del sistema hexadecimal

// Asignar varias variables a una misma posición de memoria, hace que actúen de manera dinámica al funcionar como apuntadores
// Las variables son case-sensitive

// Instrucciones. Presenta la estructura:
<Etiquetas> <Mnemónicos> <Operandos> <Comentarios>

// Las etiquetas identifican posiciones de memoria de las instrucciones
// Los mnemónicos son las abreviaturas que indican cada una de las instrucciones

// Ejemplo de la estructura de las instrucciones:
Inicio
  clrf TRISD ;Configuración de un registro
Menu
  setf aux1 ;Inicialización de una variable
  nop ;Retardo de un ciclo de bus
  bsf LATD,0 ;Manipulación de un único bit


// Comentarios
;<Comentario>

// Constantes: .<número>; ASCII: '<código ASCII>'; Hexadecimal: 0x<número>; Binario: b'<número de 8 bits>'; Octal: o'<número>'


// Sentencias

//IF
// Condicional sobre un bit. En caso de RC0=1, se salta la línea goto. Si la condición no se cumple, no se salta la línea.
// btfss --> Pregunta si el bit es 1; btfsc --> Pregunta si el bit es 0
MENU
  ***********************************
  btfss PORTC,0 ;RC0==1?
  goto SIGUIENTE
  nop
  ***********************************
SIGUIENTE 

// Condicional sobre una variable
MENU
  ***********************************
  tstfsz var1 ;var1==0?
  goto SIGUIENTE
  nop
  ***********************************
SIGUIENTE 

// Condicional sobre la comparación de variables
MENU
  ***********************************
  movf var1,w ;Cargamos la variable al registro W
  cpfseq var2 ;var1==var2?
  goto Siguiente
  nop
  ***********************************
SIGUIENTE

MENU
  ***********************************
  movf var1,w ;Cargamos la variable al registro W
  cpfsgt var2 ;var1>var2?
  goto Siguiente
  nop
  ***********************************
SIGUIENTE 

MENU
  ***********************************
  movf var1,w ;Cargamos la variable al registro W
  cpfslt var2 ;var1<var2?
  goto Siguiente
  nop
  ***********************************
SIGUIENTE 

// Condicional sobre los acarreos
// bc hace un salto relativo
MENU
  ***********************************
  movf var1,w ;Cargamos la variable al registro W
  addwf var2,w ;Se suma var2 con la variable presente en W (var1). El resultado se guarda en W.
  bc HayAcarreo ;C==1?
  ***********************************
HayAcarreo

// Condicional con sentencia ELSE

Menu
  ***********************************
  btfss PORTC,0 ;RC0==1?
  goto Apagar
  goto Encender
Encender
  ***********************************
    goto Siguiente
Apagar    
  ***********************************  
Siguiente 

// SWITCH
// opc será nuestra variable de control con la cual comparamos todos los casos
Sentencia_SWITCH
  movlw A
  cpfseq opc ;opc==A?
  goto PreguntarB
  goto CasoA
PreguntarB
  movlw B
  cpfseq opc ;opc==B?
  goto PreguntarC
  goto CasoB
PreguntarC

// WHILE o REPEAT
CicloWhile
  btfss PORTB,0 ;RB0==1?
  goto FinCiclo
  ***********************
  goto CicloWhile
FinCiclo
  ***********************

// FOR
// contador es nuestra variable de control
InicioCicloFor
  clrf contador
CicloFor
  movlw .5 ;Cargamos al registro W un tope igual a 5
  cpfslt contador ;contador<5?
  goto FinCiclo
  ***********************
  incf contador,f ;Incrementamos el contador en 1 y lo sobreescribimos
  goto CicloFor
FinCiclo
  ***********************
  
  
// Etiquetas

clrf <registro o variable> ;Limpia un registro o variable. Asigna 0.
setf <registro o variable> ;Limpia un registro o variable. Asigna 1.

// Inicializar una variable
movlw <valor> ;Se crea la constante y se mueve al registro de trabajo w.
movwf <variable> ;Carga la constante presente en w a la variable.

// Es importante resaltar que 'mov' mueve un valor de un registro a otro. Entonces movwf mueve el valor desde w hasta f (representa la variable en el operando)









// Terminar el código
end
